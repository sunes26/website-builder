import type { SeoSettings } from '../types';

/**
 * HTML Template Generator for Phase 11: Preview & HTML Export
 *
 * Generates complete HTML document structure with SEO metadata
 */

export interface HTMLTemplateOptions {
  seoSettings: SeoSettings;
  googleFontsURL?: string;
  bodyHTML: string;
  customCSS?: string;
  pages?: Array<{ id: string; name: string }>;
  currentPageId?: string;
  responsiveCSS?: string;  // Phase 14: 반응형 CSS
  cssClassesCSS?: string;  // Phase 15.1: CSS 클래스
  keyframesCSS?: string;  // Phase 15.2: 키프레임 애니메이션
}

/**
 * 완전한 HTML 문서 생성 (Phase 14: 반응형 CSS 지원)
 */
export function generateHTMLTemplate(options: HTMLTemplateOptions): string {
  const {
    seoSettings,
    googleFontsURL,
    bodyHTML,
    customCSS = '',
    pages,
    currentPageId,
    responsiveCSS = '',
    cssClassesCSS = '',  // Phase 15.1
    keyframesCSS = ''  // Phase 15.2
  } = options;

  return `<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <!-- SEO Meta Tags -->
  <title>${escapeHTML(seoSettings.title)}</title>
  <meta name="description" content="${escapeHTML(seoSettings.description)}">
  <meta name="keywords" content="${seoSettings.keywords.map(escapeHTML).join(', ')}">

  <!-- Open Graph Meta Tags -->
  <meta property="og:title" content="${escapeHTML(seoSettings.title)}">
  <meta property="og:description" content="${escapeHTML(seoSettings.description)}">
  <meta property="og:type" content="website">

  <!-- Twitter Card Meta Tags -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="${escapeHTML(seoSettings.title)}">
  <meta name="twitter:description" content="${escapeHTML(seoSettings.description)}">

  ${googleFontsURL ? generateGoogleFontsLinks(googleFontsURL) : ''}

  <style>
    /* Reset & Base Styles */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.5;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
    }

    /* Canvas Container */
    .canvas-container {
      position: relative;
      width: 100%;
      min-height: 100vh;
      overflow: hidden;
    }

    /* Page Container (for multi-page support) */
    .page-container {
      position: relative;
      width: 100%;
      min-height: 100vh;
    }

    .page-container.page-active {
      display: block;
    }

    .page-container.page-hidden {
      display: none;
    }

    /* Element Styles */
    .canvas-element {
      position: absolute;
    }

    /* Image Tag Styles */
    .canvas-element img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      display: block;
    }

    /* Lines & Arrows SVG Overlay */
    .lines-arrows-overlay {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
      z-index: 1000;
    }

    /* Custom CSS */
    ${customCSS}

    /* Phase 14: Responsive CSS */
    ${responsiveCSS}

    /* Phase 15.1: CSS Classes */
    ${cssClassesCSS}

    /* Phase 15.2: Keyframe Animations */
    ${keyframesCSS}
  </style>
</head>
<body>
  <div class="canvas-container">
    ${bodyHTML}
  </div>

  <!-- Generated by Figma Style Builder -->
  ${generateInteractionScript(pages, currentPageId)}
</body>
</html>`;
}

/**
 * Google Fonts preconnect 및 stylesheet 링크 생성
 */
function generateGoogleFontsLinks(fontsURL: string): string {
  return `
  <!-- Google Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="${fontsURL}" rel="stylesheet">`;
}

/**
 * HTML 이스케이프 (XSS 방지)
 */
function escapeHTML(text: string): string {
  const div = document.createElement('div');
  div.textContent = text;
  return div.innerHTML;
}

/**
 * 미리보기용 간단한 HTML (SEO 없이) (Phase 14: 반응형 CSS 지원)
 */
export function generatePreviewHTML(bodyHTML: string, customCSS?: string): string {
  // Phase 14: customCSS는 이제 responsiveCSS를 포함할 수 있음
  return `<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Preview</title>

  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      -webkit-font-smoothing: antialiased;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      min-height: 100vh;
      overflow: hidden;
      background: white;
    }

    .canvas-element {
      position: absolute;
    }

    ${customCSS || ''}
  </style>
</head>
<body>
  <div class="canvas-container">
    ${bodyHTML}
  </div>

  ${generateInteractionScript(undefined, undefined)}
</body>
</html>`;
}

/**
 * CSS 클래스명 생성 (요소 ID 기반)
 */
export function generateClassName(elementId: string): string {
  return `element-${elementId}`;
}

/**
 * 인라인 스타일을 CSS 클래스로 변환 (최적화용)
 */
export function generateCSSClass(
  className: string,
  styles: React.CSSProperties
): string {
  const cssProperties = Object.entries(styles)
    .map(([key, value]) => {
      const kebabKey = key.replace(/[A-Z]/g, (m) => `-${m.toLowerCase()}`);
      return `  ${kebabKey}: ${value};`;
    })
    .join('\n');

  return `.${className} {\n${cssProperties}\n}`;
}

/**
 * 인터랙션 시스템 JavaScript 생성 (Phase 13)
 */
function generateInteractionScript(
  pages?: Array<{ id: string; name: string }>,
  currentPageId?: string
): string {
  const pagesJSON = pages ? JSON.stringify(pages) : '[]';
  const initialPageId = currentPageId || (pages && pages[0]?.id) || '';

  return `
<script>
(function() {
  'use strict';

  // ============================================
  // 인터랙션 시스템 초기화
  // ============================================

  const InteractionSystem = {
    // 페이지 정보
    pages: ${pagesJSON},
    currentPageId: '${initialPageId}',

    // 초기화
    init() {
      this.setupEventListeners();
      this.handleLoadAnimations();
      this.handleScrollAnimations();
    },

    // 이벤트 리스너 설정
    setupEventListeners() {
      const container = document.querySelector('.canvas-container');
      if (!container) return;

      // 클릭 이벤트 (이벤트 위임)
      container.addEventListener('click', (e) => {
        const target = e.target.closest('[data-interactions]');
        if (target) {
          this.handleClick(target, e);
        }
      });

      // 호버 이벤트
      container.addEventListener('mouseover', (e) => {
        const target = e.target.closest('[data-interactions]');
        if (target) {
          this.handleHover(target, true);
        }
      });

      container.addEventListener('mouseout', (e) => {
        const target = e.target.closest('[data-interactions]');
        if (target) {
          this.handleHover(target, false);
        }
      });

      // 스크롤 이벤트 (throttled)
      let scrollTimeout;
      window.addEventListener('scroll', () => {
        if (scrollTimeout) clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(() => {
          this.handleScrollEvent();
        }, 100);
      });
    },

    // 클릭 핸들러
    handleClick(element, event) {
      const interactions = this.getInteractions(element);
      interactions
        .filter(i => i.event === 'click')
        .forEach(i => this.executeAction(i.action, element, event));
    },

    // 호버 핸들러
    handleHover(element, isEnter) {
      const interactions = this.getInteractions(element);
      interactions
        .filter(i => i.event === 'hover')
        .forEach(i => {
          if (i.action.type === 'hover-effect') {
            this.applyHoverEffect(element, i.action, isEnter);
          }
        });
    },

    // 스크롤 이벤트 핸들러
    handleScrollEvent() {
      document.querySelectorAll('[data-interactions]').forEach(element => {
        const interactions = this.getInteractions(element);
        interactions
          .filter(i => i.event === 'scroll')
          .forEach(i => {
            if (this.isElementInView(element)) {
              this.executeAction(i.action, element);
            }
          });
      });
    },

    // 로드 애니메이션 처리
    handleLoadAnimations() {
      document.querySelectorAll('[data-interactions]').forEach(element => {
        const interactions = this.getInteractions(element);
        interactions
          .filter(i => i.event === 'load')
          .forEach(i => this.executeAction(i.action, element));
      });
    },

    // 스크롤 애니메이션 초기화
    handleScrollAnimations() {
      this.handleScrollEvent();
    },

    // 요소가 뷰포트에 있는지 확인
    isElementInView(element) {
      const rect = element.getBoundingClientRect();
      return (
        rect.top < window.innerHeight &&
        rect.bottom > 0
      );
    },

    // 인터랙션 파싱
    getInteractions(element) {
      try {
        const data = element.dataset.interactions || '[]';
        return JSON.parse(data);
      } catch (e) {
        console.error('Failed to parse interactions:', e);
        return [];
      }
    },

    // 액션 실행
    executeAction(action, element, event) {
      switch (action.type) {
        case 'navigate':
          this.navigate(action, event);
          break;
        case 'scroll-to':
          this.scrollTo(action);
          break;
        case 'animate':
          this.animate(element, action);
          break;
      }
    },

    // 네비게이션
    navigate(action, event) {
      if (action.target === 'external') {
        if (event) event.preventDefault();
        if (action.openInNewTab) {
          window.open(action.url, '_blank', 'noopener,noreferrer');
        } else {
          window.location.href = action.url;
        }
      } else if (action.target === 'mailto' || action.target === 'tel') {
        window.location.href = action.url;
      } else if (action.target === 'internal') {
        // 내부 페이지 이동
        if (event) event.preventDefault();
        this.switchPage(action.pageId);
      }
    },

    // 페이지 전환
    switchPage(pageId) {
      if (!pageId) return;

      // 모든 페이지 숨기기
      document.querySelectorAll('.page-container').forEach(page => {
        page.classList.remove('page-active');
        page.classList.add('page-hidden');
      });

      // 대상 페이지 표시
      const targetPage = document.querySelector(\`[data-page-id="\${pageId}"]\`);
      if (targetPage) {
        targetPage.classList.remove('page-hidden');
        targetPage.classList.add('page-active');
        this.currentPageId = pageId;

        // 새 페이지의 로드 애니메이션 실행
        const pageElements = targetPage.querySelectorAll('[data-interactions]');
        pageElements.forEach(element => {
          const interactions = this.getInteractions(element);
          interactions
            .filter(i => i.event === 'load')
            .forEach(i => this.executeAction(i.action, element));
        });

        // 페이지 상단으로 스크롤
        window.scrollTo({ top: 0, behavior: 'smooth' });
      }
    },

    // 앵커 스크롤
    scrollTo(action) {
      const target = document.querySelector(\`[data-anchor-id="\${action.targetElementId}"]\`);
      if (target) {
        const offset = action.offset || 0;
        const top = target.getBoundingClientRect().top + window.pageYOffset + offset;
        window.scrollTo({
          top: top,
          behavior: action.behavior || 'smooth'
        });
      }
    },

    // 애니메이션 (Web Animations API)
    animate(element, action) {
      const keyframes = this.getAnimationKeyframes(action.animationType);
      const options = {
        duration: action.duration || 300,
        delay: action.delay || 0,
        easing: action.easing || 'ease',
        iterations: action.repeat || 1
      };

      // Infinite loop if repeat is 0
      if (action.repeat === 0) {
        options.iterations = Infinity;
      }

      element.animate(keyframes, options);
    },

    // 애니메이션 키프레임 정의
    getAnimationKeyframes(type) {
      const keyframes = {
        'fade-in': [
          { opacity: 0 },
          { opacity: 1 }
        ],
        'fade-out': [
          { opacity: 1 },
          { opacity: 0 }
        ],
        'slide-up': [
          { transform: 'translateY(50px)', opacity: 0 },
          { transform: 'translateY(0)', opacity: 1 }
        ],
        'slide-down': [
          { transform: 'translateY(-50px)', opacity: 0 },
          { transform: 'translateY(0)', opacity: 1 }
        ],
        'slide-left': [
          { transform: 'translateX(50px)', opacity: 0 },
          { transform: 'translateX(0)', opacity: 1 }
        ],
        'slide-right': [
          { transform: 'translateX(-50px)', opacity: 0 },
          { transform: 'translateX(0)', opacity: 1 }
        ],
        'scale-up': [
          { transform: 'scale(0.8)', opacity: 0 },
          { transform: 'scale(1)', opacity: 1 }
        ],
        'scale-down': [
          { transform: 'scale(1.2)', opacity: 0 },
          { transform: 'scale(1)', opacity: 1 }
        ],
        'rotate': [
          { transform: 'rotate(0deg)' },
          { transform: 'rotate(360deg)' }
        ]
      };

      return keyframes[type] || keyframes['fade-in'];
    },

    // 호버 효과 적용
    applyHoverEffect(element, action, isEnter) {
      if (isEnter) {
        // 원본 스타일 저장
        if (!element.dataset.originalStyles) {
          const computed = window.getComputedStyle(element);
          element.dataset.originalStyles = JSON.stringify({
            backgroundColor: computed.backgroundColor,
            borderColor: computed.borderColor,
            color: computed.color,
            opacity: computed.opacity,
            transform: computed.transform
          });
        }

        // 호버 스타일 적용
        const duration = action.transition.duration || 200;
        const easing = action.transition.easing || 'ease';
        element.style.transition = \`all \${duration}ms \${easing}\`;

        if (action.hoverStyles.fill) {
          element.style.backgroundColor = action.hoverStyles.fill;
        }
        if (action.hoverStyles.stroke) {
          element.style.borderColor = action.hoverStyles.stroke;
        }
        if (action.hoverStyles.color) {
          element.style.color = action.hoverStyles.color;
        }
        if (action.hoverStyles.opacity !== undefined) {
          element.style.opacity = action.hoverStyles.opacity;
        }
        if (action.hoverStyles.scale !== undefined) {
          const currentTransform = element.style.transform || '';
          const scaleTransform = \`scale(\${action.hoverStyles.scale})\`;
          element.style.transform = currentTransform.includes('scale')
            ? currentTransform.replace(/scale\\([^)]*\\)/, scaleTransform)
            : \`\${currentTransform} \${scaleTransform}\`.trim();
        }
      } else {
        // 원본 스타일 복원
        if (element.dataset.originalStyles) {
          const original = JSON.parse(element.dataset.originalStyles);
          Object.assign(element.style, {
            backgroundColor: original.backgroundColor,
            borderColor: original.borderColor,
            color: original.color,
            opacity: original.opacity,
            transform: original.transform
          });
        }
      }
    }
  };

  // DOM 로드 완료 후 초기화
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => InteractionSystem.init());
  } else {
    InteractionSystem.init();
  }
})();
</script>
  `;
}
